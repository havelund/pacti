
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>For contributors &#8212; Gear  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to Gear’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-iocontract">
<span id="for-contributors"></span><h1>For contributors<a class="headerlink" href="#module-iocontract" title="Permalink to this heading">¶</a></h1>
<span class="target" id="module-0"></span><p>IoContracts contains Gear’s basic definitions: Var, Term, TemSet, and
IoContract. Var creates variables; Term is an abstract class representing
constraints; a TermSet (also an abstract class) is a collection of terms
semantically equivalent to the term which is the conjunction of all terms
contained in the TermSet; IoContract is an assume-guarantee specification
consisting of assumptions, guarantees, and input and output variables. The
assumptions and guarantees are given by TermSets. Assumptions make predicates
only on inputs, and guarantees on both input and outputs (and no other
variable).</p>
<p>This module implements all supported contract operations and relations. In order
to instantiate contracts and perform this operations, it is necessary to extend
Term and TermSet with specific constraint formalisms.</p>
<dl class="py class">
<dt class="sig sig-object py" id="iocontract.Var">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">iocontract.</span></span><span class="sig-name descname"><span class="pre">Var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.Var" title="Permalink to this definition">¶</a></dt>
<dd><p>Variables used in system modeling.</p>
<p>Variables allow us to name an entity for which we want to write constraints.</p>
<dl class="py property">
<dt class="sig sig-object py" id="iocontract.Var.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></em><a class="headerlink" href="#iocontract.Var.name" title="Permalink to this definition">¶</a></dt>
<dd><p>The name of the variable.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="iocontract.Term">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">iocontract.</span></span><span class="sig-name descname"><span class="pre">Term</span></span><a class="headerlink" href="#iocontract.Term" title="Permalink to this definition">¶</a></dt>
<dd><p>Terms, or constraints, to be imposed on the system or components.</p>
<p>Term is an abstract class that must be extended in order to support specific
constraint languages.</p>
<dl class="py property">
<dt class="sig sig-object py" id="iocontract.Term.vars">
<em class="property"><span class="pre">abstract</span><span class="w"> </span><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vars</span></span><a class="headerlink" href="#iocontract.Term.vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Variables contained in the syntax of the term.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.Term.contains_var">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">contains_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.Var" title="iocontract.Var"><span class="pre">Var</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.Term.contains_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether term contains a given variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>var</strong> – The variable that we are seeking in the current term.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="iocontract.TermSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">iocontract.</span></span><span class="sig-name descname"><span class="pre">TermSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">termSet</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.TermSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A collection of terms, or constraints.</p>
<p>A TermSet is semantically equivalent to a single term which is the
conjunction of all terms contained in the TermSet. TermSet is an abstract
class that must be extended to support a specific constraint formalism.</p>
<dl class="py property">
<dt class="sig sig-object py" id="iocontract.TermSet.vars">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vars</span></span><a class="headerlink" href="#iocontract.TermSet.vars" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of variables contained in this set of terms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.TermSet.get_terms_with_vars">
<span class="sig-name descname"><span class="pre">get_terms_with_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_set</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#iocontract.Var" title="iocontract.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.TermSet.get_terms_with_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of terms which contain any of the variables indicated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>varSet</strong> – a set of variables being sought in current TermSet.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.TermSet.abduce_with_context">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">abduce_with_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.TermSet" title="iocontract.TermSet"><span class="pre">TermSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars_to_elim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#iocontract.Var" title="iocontract.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.TermSet.abduce_with_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Abduce terms containing variables to be eliminated using a user-provided
context.</p>
<p>Given a context <span class="math notranslate nohighlight">\(\Gamma\)</span>, and the set of terms contained in self,
<span class="math notranslate nohighlight">\(s\)</span>, this routine identifies a TermSet <span class="math notranslate nohighlight">\(x\)</span> lacking variables
vars_to_elim such that <span class="math notranslate nohighlight">\(\frac{\Gamma\colon \; x}{\Gamma: \;
s}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>context</strong> – Set of context terms that will be used to abduce the TermSet.</p></li>
<li><p><strong>vars_to_elim</strong> – Variables that cannot be present in TermSet after abduction.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.TermSet.deduce_with_context">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">deduce_with_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.TermSet" title="iocontract.TermSet"><span class="pre">TermSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars_to_elim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#iocontract.Var" title="iocontract.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.TermSet.deduce_with_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Deduce terms containing variables to be eliminated using a user-provided
context.</p>
<p>Given a context <span class="math notranslate nohighlight">\(\Gamma\)</span>, and the set of terms contained in self,
<span class="math notranslate nohighlight">\(s\)</span>, this routine identifies a formula <span class="math notranslate nohighlight">\(x\)</span> lacking variables
vars_to_elim such that <span class="math notranslate nohighlight">\(\frac{\Gamma\colon \; s}{\Gamma: \;
x}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>context</strong> – Set of context terms that will be used to abstract the TermSet.</p></li>
<li><p><strong>vars_to_elim</strong> – Variables that cannot be present in TermSet after deduction.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.TermSet.simplify">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">simplify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.TermSet.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove redundant terms in TermSet.</p>
<p>Let <span class="math notranslate nohighlight">\(S\)</span> be this TermSet and suppose <span class="math notranslate nohighlight">\(T \subseteq S\)</span>. Let
<span class="math notranslate nohighlight">\(S_T = S \setminus T\)</span>. Simplify will remove from <span class="math notranslate nohighlight">\(S\)</span> a
maximal subset <span class="math notranslate nohighlight">\(T\)</span> such that <span class="math notranslate nohighlight">\(\frac{\Gamma, S_T\colon \;
\top}{\Gamma, S_T\colon \; \wedge_{t \in T} t}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> – Set of context terms that will be used to remove redundancies in
the TermSet.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.TermSet.refines">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">refines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.TermSet" title="iocontract.TermSet"><span class="pre">TermSet</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#iocontract.TermSet.refines" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the argument is a larger specification, i.e., compute self
&lt;= other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – TermSet against which we are comparing self.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="iocontract.IoContract">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">iocontract.</span></span><span class="sig-name descname"><span class="pre">IoContract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.TermSet" title="iocontract.TermSet"><span class="pre">TermSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">guarantees</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.TermSet" title="iocontract.TermSet"><span class="pre">TermSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">inputVars</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#iocontract.Var" title="iocontract.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputVars</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Set</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#iocontract.Var" title="iocontract.Var"><span class="pre">Var</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#iocontract.IoContract" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic type for an IO contract, a structure consisting of assumptions,
guarantees, and input and output vars.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="iocontract.IoContract.inputvars">
<span class="sig-name descname"><span class="pre">inputvars</span></span><a class="headerlink" href="#iocontract.IoContract.inputvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Variables which are inputs of the implementations of the contract.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="iocontract.IoContract.outputvars">
<span class="sig-name descname"><span class="pre">outputvars</span></span><a class="headerlink" href="#iocontract.IoContract.outputvars" title="Permalink to this definition">¶</a></dt>
<dd><p>Variables which are outputs of the implementations of the contract.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="iocontract.IoContract.a">
<span class="sig-name descname"><span class="pre">a</span></span><a class="headerlink" href="#iocontract.IoContract.a" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract assumptions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#iocontract.TermSet" title="iocontract.TermSet">TermSet</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="iocontract.IoContract.g">
<span class="sig-name descname"><span class="pre">g</span></span><a class="headerlink" href="#iocontract.IoContract.g" title="Permalink to this definition">¶</a></dt>
<dd><p>Contract guarantees.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#iocontract.TermSet" title="iocontract.TermSet">TermSet</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="iocontract.IoContract.vars">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vars</span></span><a class="headerlink" href="#iocontract.IoContract.vars" title="Permalink to this definition">¶</a></dt>
<dd><p>The set of variables contained in the assumptions and guarantees of the
contract.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.IoContract.can_compose_with">
<span class="sig-name descname"><span class="pre">can_compose_with</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#iocontract.IoContract.can_compose_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the contract can be composed with another contract.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – Contract whose possibility to compose with self we are
verifying.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.IoContract.can_quotient_by">
<span class="sig-name descname"><span class="pre">can_quotient_by</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#iocontract.IoContract.can_quotient_by" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the contract can quotiented by another contract.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – potential quotient by which self would be quotiented.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.IoContract.shares_io_with">
<span class="sig-name descname"><span class="pre">shares_io_with</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#iocontract.IoContract.shares_io_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether two contracts have the same IO signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – contract whose IO signature is compared with self.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.IoContract.refines">
<span class="sig-name descname"><span class="pre">refines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#iocontract.IoContract.refines" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether the given contract is a refinement of another.</p>
<p>Return self &lt;= other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – contract being compared with self.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.IoContract.compose">
<span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></span><a class="headerlink" href="#iocontract.IoContract.compose" title="Permalink to this definition">¶</a></dt>
<dd><p>Compose IO contracts.</p>
<p>Compute the composition of the two given contracts and abstract the
result in such a way that the result is a well-defined IO contract,
i.e., that assumptions refer only to inputs, and guarantees to both
inputs and outputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – The second contract being composed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The abstracted composition of the two contracts.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="iocontract.IoContract.quotient">
<span class="sig-name descname"><span class="pre">quotient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#iocontract.IoContract" title="iocontract.IoContract"><span class="pre">IoContract</span></a></span></span><a class="headerlink" href="#iocontract.IoContract.quotient" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the contract quotient.</p>
<p>Compute the quotient self/other of the two given contracts and refine
the result in such a way that the result is a well-defined IO contract,
i.e., that assumptions refer only to inputs, and guarantees to both
inputs and outputs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – The contract by which we take the quotient.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The refined quotient self/other.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<section id="specification-formalisms">
<h2>Specification formalisms<a class="headerlink" href="#specification-formalisms" title="Permalink to this heading">¶</a></h2>
<p>As discussed above, the abstract classes Term and TermSet need to be extended
by a formalism in which specifications can be written. In this section, we
discuss available formalisms.</p>
<section id="module-polyhedralterm">
<span id="polyhedral-constraints"></span><h3>Polyhedral constraints<a class="headerlink" href="#module-polyhedralterm" title="Permalink to this heading">¶</a></h3>
<span class="target" id="module-1"></span><p>PolyhedralTerm provides support for linear inequalities as constraints, i.e.,
the constraints are of the form <span class="math notranslate nohighlight">\(\sum_{i} a_i x_i \le c\)</span>, where the
<span class="math notranslate nohighlight">\(x_i\)</span> are variables and the <span class="math notranslate nohighlight">\(a_i\)</span> and <span class="math notranslate nohighlight">\(c\)</span> are constants.</p>
<dl class="py class">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polyhedralterm.</span></span><span class="sig-name descname"><span class="pre">PolyhedralTerm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm" title="Permalink to this definition">¶</a></dt>
<dd><p>Polyhedral terms are linear inequalities over a set of variables.</p>
<dl>
<dt>Usage:</dt><dd><p>Polyhedral terms are initialized as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">Var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">):</span><span class="mi">2</span><span class="p">,</span> <span class="n">Var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">):</span><span class="mi">3</span><span class="p">}</span>
<span class="n">constant</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">term</span> <span class="o">=</span> <span class="n">PolyhedralTerm</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">variables</span></code> is a dictionary whose keys are <code class="code docutils literal notranslate"><span class="pre">Var</span></code> instances,
and <code class="code docutils literal notranslate"><span class="pre">constant</span></code> is a number. Thus, our example represents the
expression <span class="math notranslate nohighlight">\(2x + 3y \le 3\)</span>.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.vars">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vars</span></span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Variables appearing in term with a nonzero coefficient.</p>
<p class="rubric">Example</p>
<p>For the term <span class="math notranslate nohighlight">\(ax + by \le c\)</span> with variables <span class="math notranslate nohighlight">\(x\)</span> and
<span class="math notranslate nohighlight">\(y\)</span>, this function returns the set <span class="math notranslate nohighlight">\(\{x, y\}\)</span> if
<span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are nonzero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.contains_var">
<span class="sig-name descname"><span class="pre">contains_var</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.contains_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Tell whether term contains a given variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>var</strong> – The variable that we are seeking in the current term.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="code docutils literal notranslate"><span class="pre">True</span></code> if the syntax of the term refers to the given variable;
<code class="code docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.get_coefficient">
<span class="sig-name descname"><span class="pre">get_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.get_coefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Output the coefficient multiplying the given variable in the term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>var</strong> – The variable whose coefficient we are seeking.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.get_polarity">
<span class="sig-name descname"><span class="pre">get_polarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polarity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.get_polarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether the polarity of a given variable in the term matches the
given polarity.</p>
<p>The polarity of a variable in a term is defined as the polarity of the
coefficient that multiplies it in a term, e.g., the variables <span class="math notranslate nohighlight">\(x\)</span>
and <span class="math notranslate nohighlight">\(y\)</span> in the term <span class="math notranslate nohighlight">\(-2x + y \le 3\)</span> have negative and
positive polarities respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> – The variable whose polarity in the term we are seeking.</p></li>
<li><p><strong>polarity</strong> – The polarity that we are comparing against the variable’s</p></li>
<li><p><strong>polarity.</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="code docutils literal notranslate"><span class="pre">True</span></code> if the variable’s polarity matches <code class="code docutils literal notranslate"><span class="pre">polarity</span></code> and
<code class="code docutils literal notranslate"><span class="pre">False</span></code> otherwise. If the variable’s coefficient in the term
is zero, return <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.get_matching_vars">
<span class="sig-name descname"><span class="pre">get_matching_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable_polarity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.get_matching_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of variables whose polarities match the polarities
requested.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span>
<span class="n">constant</span>  <span class="o">=</span> <span class="mi">4</span>
<span class="n">term</span> <span class="o">=</span> <span class="n">PolyhedralTerm</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span>
<span class="n">polarities</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
<span class="n">term</span><span class="o">.</span><span class="n">get_matching_vars</span><span class="p">(</span><span class="n">polarities</span><span class="p">)</span>
</pre></div>
</div>
<p>The last call returns <code class="code docutils literal notranslate"><span class="pre">{y,</span> <span class="pre">z}</span></code> because the variable y matches the
requested polarity in the term, and the variable z has a zero
coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>variable_polarity</strong> – A dictionary mapping Var instances to Boolean</p></li>
<li><p><strong>variable.</strong> (<em>values indicating the polarity of the given</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If all variables in the term match the polarities specified in the
argument, the routine returns the matching variables.  Otherwise,
it returns an empty set.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.remove_variable">
<span class="sig-name descname"><span class="pre">remove_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.remove_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminates a variable from a term. This is equivalent to setting its
coefficient to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>var</strong> – variable to be eliminated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">factor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies a term by a constant factor.</p>
<p>For example, multiplying the term <span class="math notranslate nohighlight">\(2x + 3y \le 4\)</span> by the factor 2
yields <span class="math notranslate nohighlight">\(4x + 6y \le 8\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>factor</strong> – element by which the term is multiplied.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new term which is the result of the given term multiplied by
<code class="code docutils literal notranslate"><span class="pre">factor</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.substitute_variable">
<span class="sig-name descname"><span class="pre">substitute_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subst_with_term</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.substitute_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes a specified variable in a term with a given term.</p>
<p class="rubric">Example</p>
<p>In the term <span class="math notranslate nohighlight">\(2x - y \le 6\)</span>, substituting y by the term
<span class="math notranslate nohighlight">\(x + z \le 5\)</span> yields <span class="math notranslate nohighlight">\(x - z \le 1\)</span>. Observe that the
substituting term is understood as an equality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> – The term variable to be substituted.</p></li>
<li><p><strong>subst_with_term</strong> – The term used to replace var.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new term in which the variable is substituted with the given term
understood as an equality.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.to_symbolic">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">to_symbolic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.to_symbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates the variable terms of a PolyhedralTerm into a sympy
expression.</p>
<p class="rubric">Example</p>
<p>The code</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="n">variables</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span><span class="mi">3</span><span class="p">}</span> <span class="n">constant</span>  <span class="o">=</span> <span class="mi">4</span>
<span class="n">term</span> <span class="o">=</span> <span class="n">PolyhedralTerm</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">constant</span><span class="p">)</span> <span class="n">expression</span> <span class="o">=</span>
<span class="n">PolyhedralTerm</span><span class="o">.</span><span class="n">to_symbolic</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
</pre></div>
</div>
<p>yields the expression <span class="math notranslate nohighlight">\(-2x + 3y\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>term</strong> (<a class="reference internal" href="#polyhedralterm.PolyhedralTerm" title="polyhedralterm.PolyhedralTerm"><em>PolyhedralTerm</em></a>) – The term whose coefficients and variables are to be translated
to sympy’s data structure.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.to_term">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">to_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expression</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.to_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a sympy expression into a PolyhedralTerm.</p>
<p class="rubric">Example</p>
<p>The expression <span class="math notranslate nohighlight">\(2x + 3y - 1\)</span> is translated into
<code class="code docutils literal notranslate"><span class="pre">PolyhedralTerm(variables={x:2,</span> <span class="pre">y:3},</span> <span class="pre">constant=1)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>expression</strong> – The symbolic expression to be translated.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.term_to_polytope">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">term_to_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.term_to_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a term into a vector according to the given order.</p>
<p class="rubric">Example</p>
<p>The term <span class="math notranslate nohighlight">\(3x + 5y -2z \le 7\)</span> with <code class="code docutils literal notranslate"><span class="pre">variable_list</span> <span class="pre">=</span> <span class="pre">[y,</span>
<span class="pre">x,</span> <span class="pre">w,</span> <span class="pre">z]</span></code> yields the tuple <code class="code docutils literal notranslate"><span class="pre">[5,</span> <span class="pre">3,</span> <span class="pre">0,</span> <span class="pre">-2],</span> <span class="pre">7</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>term</strong> – The term to be transformed.</p></li>
<li><p><strong>variable_list</strong> – A list of variables indicating the order of appearance of
variable coefficients.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple consisting of (i) the ordered list of coefficients and (ii)
the term’s constant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.polytope_to_term">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">polytope_to_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">const</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.polytope_to_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a list of coefficients and variables into a PolyhedralTerm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>poly</strong> – An ordered list of coefficients.</p></li>
<li><p><strong>const</strong> – The term’s coefficient.</p></li>
<li><p><strong>variables</strong> – An ordered list of variables corresponding to the coefficients.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTerm.solve_for_variables">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solve_for_variables</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars_to_elim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTerm.solve_for_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpret a set of terms as equalities and solve the system of equations
for the given variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>context</strong> – The set of terms to be solved. Each term will be interpreted as
an equality.</p></li>
<li><p><strong>vars_to_elim</strong> – The set of variables whose solutions will be sought.</p></li>
</ul>
</dd>
</dl>
<p>Assumptions: the number of equations matches the number of vars_to_elim
contained in the terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A dictionary mapping variables to their solutions. The solutions are
expressed as PolyhedralTerm instances.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">polyhedralterm.</span></span><span class="sig-name descname"><span class="pre">PolyhedralTermSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">termSet</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A TermSet of PolyhedralTerm instances.</p>
<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet.abduce_with_context">
<span class="sig-name descname"><span class="pre">abduce_with_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TermSet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars_to_elim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet.abduce_with_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a set of PolyhedralTerm instances lacking the indicated variables
and implying the given TermSet in the given context.</p>
<p class="rubric">Example</p>
<p>Suppose the current set of terms is <span class="math notranslate nohighlight">\(\{x + y \le 6\}\)</span>, the
context is <span class="math notranslate nohighlight">\(\{y \le 5\}\)</span>, and the abduced terms should not
contain variable <span class="math notranslate nohighlight">\(y\)</span>. Then the current TermSet could be
abduced to <span class="math notranslate nohighlight">\(\{x \le 1\}\)</span> because <span class="math notranslate nohighlight">\(x \le 1
\;\land\; y \le 5 \Rightarrow x + y \le 6\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>context</strong> – The TermSet providing the context for the abduction.</p></li>
<li><p><strong>vars_to_elim</strong> – Variables that should not appear in the abduced term.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet.deduce_with_context">
<span class="sig-name descname"><span class="pre">deduce_with_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TermSet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vars_to_elim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet.deduce_with_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a set of PolyhedralTerm instances lacking the indicated variables
and implied by the given TermSet in the given context.</p>
<p class="rubric">Example</p>
<p>Suppose the current set of terms is <span class="math notranslate nohighlight">\(\{x - y \le 6\}\)</span>, the
context is <span class="math notranslate nohighlight">\(\{y \le 5\}\)</span>, and the deduced terms should not
contain variable <span class="math notranslate nohighlight">\(y\)</span>. Then the current TermSet could be
deduced to <span class="math notranslate nohighlight">\(\{x \le 11\}\)</span> because <span class="math notranslate nohighlight">\(x - y \le 6
\;\land\; y \le 5 \Rightarrow x \le 11\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>context</strong> – The TermSet providing the context for the deduction.</p></li>
<li><p><strong>vars_to_elim</strong> – Variables that should not appear in the deduced term.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet.simplify">
<span class="sig-name descname"><span class="pre">simplify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet.simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove redundant terms in the PolyhedralTermSet using the provided
context.</p>
<p class="rubric">Example</p>
<p>Suppose the TermSet is <span class="math notranslate nohighlight">\(\{x - 2y \le 5, x - y \le 0\}\)</span> and
the context is <span class="math notranslate nohighlight">\(\{x + y \le 0\}\)</span>. Then the TermSet could be
simplified to <span class="math notranslate nohighlight">\(\{x - y \le 0\}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> – The TermSet providing the context for the simplification.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet.refines">
<span class="sig-name descname"><span class="pre">refines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet.refines" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells whether the argument is a larger specification, i.e., compute self
&lt;= other.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>other</strong> – TermSet against which we are comparing self.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet.termset_to_polytope">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">termset_to_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">terms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#polyhedralterm.PolyhedralTermSet" title="polyhedralterm.PolyhedralTermSet"><span class="pre">PolyhedralTermSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#polyhedralterm.PolyhedralTermSet" title="polyhedralterm.PolyhedralTermSet"><span class="pre">PolyhedralTermSet</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet.termset_to_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a set of terms with its context into matrix-vector pairs.</p>
<p class="rubric">Example</p>
<p>Suppose the set of terms is <span class="math notranslate nohighlight">\(\{x+y \le 1, x - y \le 4\}\)</span>
and the context is <span class="math notranslate nohighlight">\(\{x + 4w \le 5\}\)</span>. The routine extracts
all variables and generates an order for them, say, <span class="math notranslate nohighlight">\([x, w,
y]\)</span>. Then the routine returns matrix-vector pairs for both the terms
TermSet and the context. It returns <span class="math notranslate nohighlight">\(A = \left(
\begin{smallmatrix} 1 &amp; 0 &amp; 1 \\ 1 &amp;0 &amp;-1
\end{smallmatrix}\right)\)</span> and <span class="math notranslate nohighlight">\(b = \left(
\begin{smallmatrix} 1 \\ 4 \end{smallmatrix}\right)\)</span> for the
current TermSet and <span class="math notranslate nohighlight">\(A_{c} = \left( \begin{smallmatrix} 1 &amp;
4 &amp; 0 \end{smallmatrix}\right)\)</span> and <span class="math notranslate nohighlight">\(b_c = \left(
\begin{smallmatrix} 5 \end{smallmatrix}\right)\)</span> for the context.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>terms</strong> – Set of terms to convert to matrix-vector form.</p></li>
<li><p><strong>context</strong> – Context terms to convert to matrix-vector form.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple <code class="code docutils literal notranslate"><span class="pre">variables,</span> <span class="pre">A,</span> <span class="pre">b,</span> <span class="pre">a_h,</span> <span class="pre">b_h</span></code> consisting of the variable
order and the matrix-vector pairs for the terms and the context.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet.polytope_to_termset">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">polytope_to_termset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">gear.iocontract.Var</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#polyhedralterm.PolyhedralTermSet" title="polyhedralterm.PolyhedralTermSet"><span class="pre">PolyhedralTermSet</span></a></span></span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet.polytope_to_termset" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms a matrix-vector pair into a PolyhedralTermSet, assuming that
the variable coefficients in the matrix are ordered as specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> – The matrix of the pair.</p></li>
<li><p><strong>vector</strong> – The vector of the pair.</p></li>
<li><p><strong>variables</strong> – A list indicating the variable which corresponds to each column
of the matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The PolyhedralTermSet corresponding to the given data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="polyhedralterm.PolyhedralTermSet.reduce_polytope">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">reduce_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_help</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">shape=(1,</span> <span class="pre">0),</span> <span class="pre">dtype=float64)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_help</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=float64)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#polyhedralterm.PolyhedralTermSet.reduce_polytope" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate redundant constraints from the H-representation of a given
polytope using as context a given polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> – Matrix of H-representation of polytope to reduce.</p></li>
<li><p><strong>b</strong> – Vector of H-representation of polytope to reduce.</p></li>
<li><p><strong>a_help</strong> – Matrix of H-representation of context polytope.</p></li>
<li><p><strong>b_help</strong> – Vector of H-representation of context polytope.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Gear</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">For contributors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#specification-formalisms">Specification formalisms</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to Gear’s documentation!</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, GearDevTeam.
      
      |
      <a href="_sources/api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>